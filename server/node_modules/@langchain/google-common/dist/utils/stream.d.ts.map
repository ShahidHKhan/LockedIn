{"version":3,"file":"stream.d.ts","names":["AbstractStream","Promise","complexValue","simpleValue","JsonStream","ComplexJsonStream","ReadableAbstractStream","TextDecoder","ReadableStream","ReadableJsonStream","SseStream","Record","ReadableSseStream","SseJsonStream","ReadableSseJsonStream"],"sources":["../../src/utils/stream.d.ts"],"sourcesContent":["export interface AbstractStream {\n    /**\n     * Add more text to the buffer\n     * @param data\n     */\n    appendBuffer(data: string): void;\n    /**\n     * Indicate that there is no more text to be added to the buffer\n     * (ie - our source material is done)\n     */\n    closeBuffer(): void;\n    /**\n     * Get the next chunk that is coming from the stream.\n     * This chunk may be null, usually indicating the last chunk in the stream.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    nextChunk(): Promise<any>;\n    /**\n     * Is the stream done?\n     * A stream is only done if all of the following are true:\n     * - There is no more data to be added to the text buffer\n     * - There is no more data in the text buffer\n     * - There are no chunks that are waiting to be consumed\n     */\n    get streamDone(): boolean;\n}\nexport declare function complexValue(value: unknown): unknown;\nexport declare function simpleValue(val: unknown): unknown;\nexport declare class JsonStream implements AbstractStream {\n    _buffer: string;\n    _bufferOpen: boolean;\n    _firstRun: boolean;\n    /**\n     * Add data to the buffer. This may cause chunks to be generated, if available.\n     * @param data\n     */\n    appendBuffer(data: string): void;\n    /**\n     * Indicate there is no more data that will be added to the text buffer.\n     * This should be called when all the data has been read and added to indicate\n     * that we should process everything remaining in the buffer.\n     */\n    closeBuffer(): void;\n    /**\n     * Skip characters in the buffer till we get to the start of an object.\n     * Then attempt to read a full object.\n     * If we do read a full object, turn it into a chunk and send it to the chunk handler.\n     * Repeat this for as much as we can.\n     */\n    _parseBuffer(): void;\n    /**\n     * If the string is present, move the start of the buffer to the first occurrence\n     * of that string. This is useful for skipping over elements or parts that we're not\n     * really interested in parsing. (ie - the opening characters, comma separators, etc.)\n     * @param start The string to start the buffer with\n     */\n    _skipTo(start: string): void;\n    /**\n     * Given what is in the buffer, parse a single object out of it.\n     * If a complete object isn't available, return null.\n     * Assumes that we are at the start of an object to parse.\n     */\n    _getFullObject(): object | null;\n    _simplifyObject(obj: unknown): object;\n    // Set up a potential Promise that the handler can resolve.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _chunkResolution: (chunk: any) => void;\n    // If there is no Promise (it is null), the handler must add it to the queue\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _chunkPending: Promise<any> | null;\n    // A queue that will collect chunks while there is no Promise\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _chunkQueue: any[];\n    /**\n     * Register that we have another chunk available for consumption.\n     * If we are waiting for a chunk, resolve the promise waiting for it immediately.\n     * If not, then add it to the queue.\n     * @param chunk\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _handleChunk(chunk: any): void;\n    /**\n     * Get the next chunk that is coming from the stream.\n     * This chunk may be null, usually indicating the last chunk in the stream.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    nextChunk(): Promise<any>;\n    /**\n     * Is the stream done?\n     * A stream is only done if all of the following are true:\n     * - There is no more data to be added to the text buffer\n     * - There is no more data in the text buffer\n     * - There are no chunks that are waiting to be consumed\n     */\n    get streamDone(): boolean;\n}\nexport declare class ComplexJsonStream extends JsonStream {\n    _simplifyObject(obj: unknown): object;\n}\nexport declare class ReadableAbstractStream implements AbstractStream {\n    private baseStream;\n    decoder: TextDecoder;\n    constructor(baseStream: AbstractStream, body: ReadableStream | null);\n    appendBuffer(data: string): void;\n    closeBuffer(): void;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    nextChunk(): Promise<any>;\n    get streamDone(): boolean;\n    // Should be a ReadableStream, but the Gaxios Readable stream isn't.\n    // But both should support async iterators, so make sure of that.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    run(body: any): Promise<void>;\n}\nexport declare class ReadableJsonStream extends ReadableAbstractStream {\n    constructor(body: ReadableStream | null);\n}\nexport declare class SseStream implements AbstractStream {\n    _buffer: string;\n    _bufferOpen: boolean;\n    appendBuffer(data: string): void;\n    closeBuffer(): void;\n    /**\n     * Attempt to load an entire event.\n     * For each entire event we load,\n     * send them to be handled.\n     */\n    _parseBuffer(): void;\n    /**\n     * Given an event string, get all the fields\n     * in the event. It is assumed there is one field\n     * per line, but that field names can be duplicated,\n     * indicating to append the new value to the previous value\n     * @param event\n     */\n    _parseEvent(event: string | null): Record<string, string> | null;\n    // Set up a potential Promise that the handler can resolve.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _chunkResolution: (chunk: any) => void;\n    // If there is no Promise (it is null), the handler must add it to the queue\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _chunkPending: Promise<any> | null;\n    // A queue that will collect chunks while there is no Promise\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _chunkQueue: any[];\n    _handleEvent(event: string | null): void;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    nextChunk(): Promise<any>;\n    get streamDone(): boolean;\n}\nexport declare class ReadableSseStream extends ReadableAbstractStream {\n    constructor(body: ReadableStream | null);\n}\nexport declare class SseJsonStream extends SseStream {\n    _jsonAttribute: string;\n    constructor(jsonAttribute?: string);\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    nextChunk(): Promise<any>;\n}\nexport declare class ReadableSseJsonStream extends ReadableAbstractStream {\n    constructor(body: ReadableStream | null);\n}\n"],"mappings":";UAAiBA,cAAAA;EAAAA;AA0BjB;AACA;AACA;EAA+B,YAAA,CAAA,IAAA,EAAA,MAAA,CAAA,EAAA,IAAA;EAAA;;;AAA0B;EAoEpCK,WAAAA,EAAAA,EAAAA,IAAAA;EAGAC;;;;EAGqB;EAAsB,SAI/CL,EAAAA,EA1FAA,OA0FAA,CAAAA,GAAAA,CAAAA;EAAO;;AAP6C;AAcrE;;;;EAAsE,IAAA,UAAA,EAAA,EAAA,OAAA;AAGtE;AAA8B,iBA1FNC,YAAAA,CA0FM,KAAA,EAAA,OAAA,CAAA,EAAA,OAAA;AAkBSS,iBA3GfR,WAAAA,CA2GeQ,GAAAA,EAAAA,OAAAA,CAAAA,EAAAA,OAAAA;AAMpBV,cAhHEG,UAAAA,YAAsBJ,cAgHxBC,CAAAA;EAAO,OAMTA,EAAAA,MAAAA;EAAO,WA9BkBD,EAAAA,OAAAA;EAAc,SAAA,EAAA,OAAA;EAiCnCY;;;;EAAgD,YAAA,CAAA,IAAA,EAAA,MAAA,CAAA,EAAA,IAAA;EAGhDC;;;;AAA+B;EAM/BC,WAAAA,CAAAA,CAAAA,EAAAA,IAAAA;EAAqB;;;AAA+B;;;;;;;;;;;;;;;;;;;;;;;iBAzFtDb;;;;;;;;;;;;;;;;;eAiBFA;;;;;;;;;;cAUII,iBAAAA,SAA0BD,UAAU;;;cAGpCE,sBAAAA,YAAkCN;;WAE1CO;0BACeP,sBAAsBQ;;;;eAIjCP;;;;;kBAKGA;;cAECQ,kBAAAA,SAA2BH,sBAAAA;oBAC1BE;;cAEDE,SAAAA,YAAqBV;;;;;;;;;;;;;;;;;;qCAkBHW;;;;;;iBAMpBV;;;;;;eAMFA;;;cAGIW,iBAAAA,SAA0BN,sBAAAA;oBACzBE;;cAEDK,aAAAA,SAAsBH,SAAAA;;;;eAI1BT;;cAEIa,qBAAAA,SAA8BR,sBAAAA;oBAC7BE"}